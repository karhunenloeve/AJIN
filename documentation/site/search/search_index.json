{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00f0SIML Requirements For this package we use the gcc compiler. Please install gcc using one of the following commands for the linux distributions Arch, Solus4 or Ubuntu : # Archlinux sudo pacman -S gcc # Solus4 sudo eopkg install gcc # These are the requirements to run gcc for Solus4 sudo eopkg install -c system.devel # Ubuntu sudo apt update sudo apt install build-essential sudo apt-get install python3-dev sudo apt-get install manpages-dev gcc --version Some packages are way easier to install using Anaconda. For the installation on several linux distributions please follow this link . Further the installation of our clustering prototype requires some python packages to be installed. We provide a requirements file, but here is a complete list for manual installation using pip3 and python 3 : pip3 install pandas pip3 install sklearn # Works only with gcc installed. pip3 install hdbscan # Install Gudhi, easiest installation with Anaconda. # Gudhi is a library to compute persistent homology. conda install -c conda-forge gudhi conda install -c conda-forge/label/cf201901 gudhi","title":"Home"},{"location":"#siml","text":"","title":"\u00f0SIML"},{"location":"#requirements","text":"For this package we use the gcc compiler. Please install gcc using one of the following commands for the linux distributions Arch, Solus4 or Ubuntu : # Archlinux sudo pacman -S gcc # Solus4 sudo eopkg install gcc # These are the requirements to run gcc for Solus4 sudo eopkg install -c system.devel # Ubuntu sudo apt update sudo apt install build-essential sudo apt-get install python3-dev sudo apt-get install manpages-dev gcc --version Some packages are way easier to install using Anaconda. For the installation on several linux distributions please follow this link . Further the installation of our clustering prototype requires some python packages to be installed. We provide a requirements file, but here is a complete list for manual installation using pip3 and python 3 : pip3 install pandas pip3 install sklearn # Works only with gcc installed. pip3 install hdbscan # Install Gudhi, easiest installation with Anaconda. # Gudhi is a library to compute persistent homology. conda install -c conda-forge gudhi conda install -c conda-forge/label/cf201901 gudhi","title":"Requirements"},{"location":"cluster/","text":"compute_imagets ts_gaf_transform ts_gaf_transform(timeseries:numpy.ndarray, upper_bound:float=1.0, lower_bound:float=-1.0) -> tuple Compute the Gramian Angular Field of a time series. The Gramian Angular Field is a bijective transformation of time series data into an image of dimension n+1 . Inserting an n -dimensional time series gives an (n x n) -dimensional array with the corresponding encoded time series data. param timeseries : time series data, type np.ndarray . param upper_bound : upper bound for scaling, type float . param lower_bound : lower bound for scaling, type float . return tuple : (GAF, phi, r, scaled-series), type tuple .","title":"Clustering"},{"location":"cluster/#compute_imagets","text":"","title":"compute_imagets"},{"location":"cluster/#ts_gaf_transform","text":"ts_gaf_transform(timeseries:numpy.ndarray, upper_bound:float=1.0, lower_bound:float=-1.0) -> tuple Compute the Gramian Angular Field of a time series. The Gramian Angular Field is a bijective transformation of time series data into an image of dimension n+1 . Inserting an n -dimensional time series gives an (n x n) -dimensional array with the corresponding encoded time series data. param timeseries : time series data, type np.ndarray . param upper_bound : upper bound for scaling, type float . param lower_bound : lower bound for scaling, type float . return tuple : (GAF, phi, r, scaled-series), type tuple .","title":"ts_gaf_transform"},{"location":"helper/","text":"helper ts_iterative_descent ts_iterative_descent(data:numpy.ndarray, function:Callable) -> numpy.ndarray Iterative process an np.ndarray of shape (m,n) . This function processes an np.ndarray filled columnwise with time series data. We consider an (m,n) -dimensional array and perform the callable over the m th row of the dataset. Our result is an np.ndarray with dimension (m,l) . This function treats the row vectors as time series. Therefore the time series must be ordered by the first index m . param data : multidimensional data, type np.ndarray . param function : callable, type Callable . return proc_data : all kind of processed data. ts_recursive_descent ts_recursive_descent(data:numpy.ndarray, function:Callable) Recursivly process an np.ndarray until the last dimension. This function applies a callable to the very last dimension of a numpy multidimensional array. It is foreseen for time series processing expecially in combination with the function ts_gaf_transform . param data : multidimensional data, type np.ndarray . param function : callable, type Callable . return function(data) : all kind of processed data.","title":"Auxiliary"},{"location":"helper/#helper","text":"","title":"helper"},{"location":"helper/#ts_iterative_descent","text":"ts_iterative_descent(data:numpy.ndarray, function:Callable) -> numpy.ndarray Iterative process an np.ndarray of shape (m,n) . This function processes an np.ndarray filled columnwise with time series data. We consider an (m,n) -dimensional array and perform the callable over the m th row of the dataset. Our result is an np.ndarray with dimension (m,l) . This function treats the row vectors as time series. Therefore the time series must be ordered by the first index m . param data : multidimensional data, type np.ndarray . param function : callable, type Callable . return proc_data : all kind of processed data.","title":"ts_iterative_descent"},{"location":"helper/#ts_recursive_descent","text":"ts_recursive_descent(data:numpy.ndarray, function:Callable) Recursivly process an np.ndarray until the last dimension. This function applies a callable to the very last dimension of a numpy multidimensional array. It is foreseen for time series processing expecially in combination with the function ts_gaf_transform . param data : multidimensional data, type np.ndarray . param function : callable, type Callable . return function(data) : all kind of processed data.","title":"ts_recursive_descent"},{"location":"tda/","text":"homological_sampling sample_dsphere def sample_dsphere(dimension: int, amount: int, radius: float = 1) -> np.ndarray Create uniform random sampling of a d-sphere. This algorithm generates a certain set of normally distributed random variables. Since the multivariate normal distribution of (x1, ..., xn) is rotationally symmetrical about the origin, data can be generated on a sphere. The computation time for this algorithm is O(n * d) , with n being the number of samples and d the number of dimensions. param dimension : as dimension of the embedding space, type int . param amount : amount of sample points, type float . param radius : radius of the d-sphere, type float . return np.ndarray : data points, type np.ndarray . sample_dball def sample_dball(dimension: int, amount: int, radius: float = 1) -> np.ndarray Sample from a d-ball by drop of coordinates. Similar to the sphere, values are randomly assigned to each dimension dimension from a certain interval evenly distributed. Since the radius can be determined via the norm of the boundary points, these is also the parameter for the maximum radius. Note that there will no points be sampled on the boundary itself. The computation time for this algorithm is O(n * d) , with n being the number of samples and d the number of dimensions. param dimension : as dimension of the embedding space, type int . param amount : amount of sample points, type float . param radius : radius of the d-sphere, type float . return np.ndarray : data points, type np.ndarray . sample_dtorus_cursed def sample_dtorus_cursed(dimension: int, amount: int, radii: list) -> np.ndarray Sample from a d-torus by rejection. The function is named cursed, because the curse of dimensionality leads to an exponential grouth in time. The samples are drawn and then rejected if the lie on the algebraic variety of the torus. Unfortunately the curse of dimensionality makes the computation time exponential in the number of dimensions. Therefore this is just a prototype for low dimensional sampling param dimension : as dimension of the embedding space, type int . param amount : amount of sample points, type float . param radii : radii of the torical spheres, type list . return np.ndarray : data points, type np.ndarray .","title":"TDA"},{"location":"tda/#homological_sampling","text":"","title":"homological_sampling"},{"location":"tda/#sample_dsphere","text":"def sample_dsphere(dimension: int, amount: int, radius: float = 1) -> np.ndarray Create uniform random sampling of a d-sphere. This algorithm generates a certain set of normally distributed random variables. Since the multivariate normal distribution of (x1, ..., xn) is rotationally symmetrical about the origin, data can be generated on a sphere. The computation time for this algorithm is O(n * d) , with n being the number of samples and d the number of dimensions. param dimension : as dimension of the embedding space, type int . param amount : amount of sample points, type float . param radius : radius of the d-sphere, type float . return np.ndarray : data points, type np.ndarray .","title":"sample_dsphere"},{"location":"tda/#sample_dball","text":"def sample_dball(dimension: int, amount: int, radius: float = 1) -> np.ndarray Sample from a d-ball by drop of coordinates. Similar to the sphere, values are randomly assigned to each dimension dimension from a certain interval evenly distributed. Since the radius can be determined via the norm of the boundary points, these is also the parameter for the maximum radius. Note that there will no points be sampled on the boundary itself. The computation time for this algorithm is O(n * d) , with n being the number of samples and d the number of dimensions. param dimension : as dimension of the embedding space, type int . param amount : amount of sample points, type float . param radius : radius of the d-sphere, type float . return np.ndarray : data points, type np.ndarray .","title":"sample_dball"},{"location":"tda/#sample_dtorus_cursed","text":"def sample_dtorus_cursed(dimension: int, amount: int, radii: list) -> np.ndarray Sample from a d-torus by rejection. The function is named cursed, because the curse of dimensionality leads to an exponential grouth in time. The samples are drawn and then rejected if the lie on the algebraic variety of the torus. Unfortunately the curse of dimensionality makes the computation time exponential in the number of dimensions. Therefore this is just a prototype for low dimensional sampling param dimension : as dimension of the embedding space, type int . param amount : amount of sample points, type float . param radii : radii of the torical spheres, type list . return np.ndarray : data points, type np.ndarray .","title":"sample_dtorus_cursed"}]}
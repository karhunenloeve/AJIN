<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Topological Data Analysis - Ajin</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Topological Data Analysis";
    var mkdocs_page_input_path = "tda.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Ajin</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../clustering/">Clustering</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">Topological Data Analysis</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#tda">tda</a></li>
    

    <li class="toctree-l2"><a href="#tdahomologicalsampling">tda.homologicalSampling</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#sample_dsphere">sample_dsphere</a></li>
        
            <li><a class="toctree-l3" href="#sample_dball">sample_dball</a></li>
        
            <li><a class="toctree-l3" href="#sample_dtorus_cursed">sample_dtorus_cursed</a></li>
        
            <li><a class="toctree-l3" href="#sample_torus">sample_torus</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#tdapersistencehomology">tda.persistenceHomology</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#persistent_homology">persistent_homology</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#tdapersistencelandscapes">tda.persistenceLandscapes</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#concatenate_landscapes">concatenate_landscapes</a></li>
        
            <li><a class="toctree-l3" href="#compute_persistence_landscape">compute_persistence_landscape</a></li>
        
            <li><a class="toctree-l3" href="#compute_mean_persistence_landscapes">compute_mean_persistence_landscapes</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#tdapersistencestatistics">tda.persistenceStatistics</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#hausd_interval">hausd_interval</a></li>
        
            <li><a class="toctree-l3" href="#truncated_simplex_tree">truncated_simplex_tree</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../auxiliary/">Auxiliary</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Ajin</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Topological Data Analysis</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="tda">tda</h1>
<h1 id="tdahomologicalsampling">tda.homologicalSampling</h1>
<h2 id="sample_dsphere">sample_dsphere</h2>
<pre><code class="python">sample_dsphere(dimension: int, amount: int, radius: float = 1) -&gt; numpy.ndarray
</code></pre>

<p><strong>Create uniform random sampling of a d-sphere.</strong></p>
<p>This algorithm generates a certain set of normally distributed random variables.
Since the multivariate normal distribution of <code>(x1, ..., xn)</code> is rotationally symmetrical about the
origin, data can be generated on a sphere. The computation time for this algorithm is <code>O(n * d)</code>,
with <code>n</code> being the number of samples and <code>d</code> the number of dimensions.</p>
<ul>
<li>param <strong>dimension</strong>: as dimension of the embedding space, type <code>int</code>.</li>
<li>param <strong>amount</strong>: amount of sample points, type <code>float</code>.</li>
<li>param <strong>radius</strong>: radius of the d-sphere, type <code>float</code>.</li>
<li>return <strong>np.ndarray</strong>: data points, type <code>np.ndarray</code>.</li>
</ul>
<h2 id="sample_dball">sample_dball</h2>
<pre><code class="python">sample_dball(dimension: int, amount: int, radius: float = 1) -&gt; numpy.ndarray
</code></pre>

<p><strong>Sample from a d-ball by drop of coordinates.</strong></p>
<p>Similar to the sphere, values are randomly assigned to each dimension dimension from a certain interval
evenly distributed. Since the radius can be determined via the norm of the boundary points, these
is also the parameter for the maximum radius. Note that there will no points be sampled on the boundary itself.
The computation time for this algorithm is <code>O(n * d)</code>, with <code>n</code> being the number of samples
and <code>d</code> the number of dimensions.</p>
<ul>
<li>param <strong>dimension</strong>: as dimension of the embedding space, type <code>int</code>.</li>
<li>param <strong>amount</strong>: amount of sample points, type <code>float</code>.</li>
<li>param <strong>radius</strong>: radius of the d-sphere, type <code>float</code>.</li>
<li>return <strong>np.ndarray</strong>: data points, type <code>np.ndarray</code>.</li>
</ul>
<h2 id="sample_dtorus_cursed">sample_dtorus_cursed</h2>
<pre><code class="python">sample_dtorus_cursed(dimension: int, amount: int, radii: list) -&gt; numpy.ndarray
</code></pre>

<p><strong>Sample from a d-torus by rejection.</strong></p>
<p>The function is named cursed, because the curse of dimensionality leads to an exponential grouth in time.
The samples are drawn and then rejected if the lie on the algebraic variety of the torus. Unfortunately
the curse of dimensionality makes the computation time exponential in the number of dimensions. Therefore
this is just a prototype for low dimensional sampling</p>
<ul>
<li>param <strong>dimension</strong>: as dimension of the embedding space, type <code>int</code>.</li>
<li>param <strong>amount</strong>: amount of sample points, type <code>float</code>.</li>
<li>param <strong>radii</strong>: radii of the torical spheres, type <code>list</code>.</li>
<li>return <strong>np.ndarray</strong>: data points, type <code>np.ndarray</code>.</li>
</ul>
<h2 id="sample_torus">sample_torus</h2>
<pre><code class="python">sample_torus(dimension: int, amount: int, radii: list) -&gt; numpy.ndarray
</code></pre>

<p><strong>Sample from a d-torus.</strong></p>
<p>The function is named cursed, because the curse of dimensionality leads to an exponential grouth in time.
The samples are drawn and then rejected if the lie on the algebraic variety of the torus. Unfortunately
the curse of dimensionality makes the computation time exponential in the number of dimensions. Therefore
this is just a prototype for low dimensional sampling</p>
<ul>
<li>param <strong>dimension</strong>: as dimension of the embedding space, type <code>int</code>.</li>
<li>param <strong>amount</strong>: amount of sample points, type <code>float</code>.</li>
<li>param <strong>radii</strong>: radii of the torical spheres, type <code>list</code>.</li>
<li>return <strong>list</strong>: data points, type <code>list</code>.</li>
</ul>
<h1 id="tdapersistencehomology">tda.persistenceHomology</h1>
<h2 id="persistent_homology">persistent_homology</h2>
<pre><code class="python">persistent_homology(data: numpy.ndarray, plot: bool = False, tikzplot: bool = False, maxEdgeLength: int = 42, maxDimension: int = 10, maxAlphaSquare: float = 1000000000000.0, homologyCoeffField: int = 2, minPersistence: float = 0, filtration: str = ['alphaComplex', 'vietorisRips', 'tangential'])
</code></pre>

<p><strong>Create persistence diagram.</strong></p>
<p>This function computes the persistent homology of a dataset upon a filtration of a chosen
simplicial complex. It can be used for plotting or scientific displaying of persistent homology classes.</p>
<ul>
<li>param <strong>data</strong>: data, type <code>np.ndarray</code>.</li>
<li>param <strong>plot</strong>: whether or not to plot the persistence diagram using matplotlib, type <code>bool</code>.</li>
<li>param <strong>tikzplot</strong>: whether or not to create a tikz file from persistent homology, type <code>bool</code>.</li>
<li>param <strong>maxEdgeLength</strong>: maximal edge length of simplicial complex, type <code>int</code>.</li>
<li>param <strong>maxDimension</strong>: maximal dimension of simplicial complex, type <code>int</code>.</li>
<li>param <strong>maxAlphaSquare</strong>: alpha square value for Delaunay complex, type <code>float</code>.</li>
<li>param <strong>homologyCoeffField</strong>: integers, cyclic moduli integers, rationals enumerated, type <code>int</code>.</li>
<li>param <strong>minPersistence</strong>: minimal persistence of homology class, type <code>float</code>.</li>
<li>param <strong>filtration</strong>: the used filtration to calculate persistent homology, type <code>str</code>.</li>
<li>return <strong>np.ndarray</strong>: data points, type <code>np.ndarray</code>.</li>
</ul>
<h1 id="tdapersistencelandscapes">tda.persistenceLandscapes</h1>
<h2 id="concatenate_landscapes">concatenate_landscapes</h2>
<pre><code class="python">concatenate_landscapes(persLandscape1: numpy.ndarray, persLandscape2: numpy.ndarray, resolution: int) -&gt; list
</code></pre>

<p><strong>This function concatenates the persistence landscapes according to homology groups.</strong></p>
<p>The computation of homology groups requires a certain resolution for each homology class.
According to this resolution the direct sum of persistence landscapes has to be concatenated
in a correct manner, such that the persistent homology can be plotted according to the <code>n</code>-dimensional
persistent homology groups.</p>
<ul>
<li>param <strong>persLandscape1</strong>: persistence landscape, type <code>np.ndarray</code>.</li>
<li>param <strong>persLandscape2</strong>: persistence landscape, type <code>np.ndarray</code>.</li>
<li>return <strong>concatenatedLandscape</strong>: direct sum of persistence landscapes, type <code>list</code>.</li>
</ul>
<h2 id="compute_persistence_landscape">compute_persistence_landscape</h2>
<pre><code class="python">compute_persistence_landscape(data: numpy.ndarray, res: int = 1000, persistenceIntervals: int = 1, maxAlphaSquare: float = 1000000000000.0, filtration: str = ['alphaComplex', 'vietorisRips', 'tangential'], maxDimensions: int = 10, edgeLength: float = 0.1, plot: bool = False, smoothen: bool = False, sigma: int = 3) -&gt; numpy.ndarray
</code></pre>

<p><strong>A function for computing persistence landscapes for 2D images.</strong></p>
<p>This function computes the filtration of a 2D image dataset, the simplicial complex,
the persistent homology and then returns the persistence landscape as array. It takes
the resolution of the landscape as parameter, the maximum size for <code>alphaSquare</code> and
options for certain filtrations.</p>
<ul>
<li>param <strong>data</strong>: data set, type <code>np.ndarray</code>.</li>
<li>param <strong>res</strong>: resolution, default is <code>1000</code>, type <code>int</code>.</li>
<li>param <strong>persistenceIntervals</strong>: interval for persistent homology, default is <code>1e12</code>,type <code>float</code>.</li>
<li>param <strong>maxAlphaSquare</strong>: max. parameter for delaunay expansion, type <code>float</code>.</li>
<li>param <strong>filtration</strong>: alphaComplex, vietorisRips, cech, delaunay, tangential, type <code>str</code>.</li>
<li>param <strong>maxDimensions</strong>: only needed for VietorisRips, type <code>int</code>.</li>
<li>param <strong>edgeLength</strong>: only needed for VietorisRips, type <code>float</code>.</li>
<li>param <strong>plot</strong>: whether or not to plot, type <code>bool</code>.</li>
<li>param <strong>smoothen</strong>: whether or not to smoothen the landscapes, type <code>bool</code>.</li>
<li>param <strong>sigma</strong>: smoothing factor for gaussian mixtures, type <code>int</code>.</li>
<li>return <strong>landscapeTransformed</strong>: persistence landscape, type <code>np.ndarray</code>.</li>
</ul>
<h2 id="compute_mean_persistence_landscapes">compute_mean_persistence_landscapes</h2>
<pre><code class="python">compute_mean_persistence_landscapes(data: numpy.ndarray, resolution: int = 1000, persistenceIntervals: int = 1, maxAlphaSquare: float = 1000000000000.0, filtration: str = ['alphaComplex', 'vietorisRips', 'tangential'], maxDimensions: int = 10, edgeLength: float = 0.1, plot: bool = False, tikzplot: bool = False, name: str = 'persistenceLandscape', smoothen: bool = False, sigma: int = 2) -&gt; numpy.ndarray
</code></pre>

<p><strong>This function computes mean persistence diagrams over 2D datasets.</strong></p>
<p>The functions shows a progress bar of the processed data and takes the direct
sum of the persistence modules to get a summary of the landscapes of the various
samples. Further it can be decided whether or not to smoothen the persistence
landscape by gaussian filter. A plot can be created with <code>matplotlib</code> or as
another option for scientific reporting with <code>tikzplotlib</code>, or both.</p>
<p>Information: The color scheme has 5 colors defined. Thus 5 homology groups can be
displayed in different colors.</p>
<ul>
<li>param <strong>data</strong>: data set, type <code>np.ndarray</code>.</li>
<li>param <strong>resolution</strong>: resolution of persistent homology per group, type <code>int</code>.</li>
<li>param <strong>persistenceIntervals</strong>: intervals for persistence classes, type <code>int</code>.</li>
<li>param <strong>maxAlphaSquare</strong>: max. parameter for Delaunay expansion, type <code>float</code>.</li>
<li>param <strong>filtration</strong>: <code>alphaComplex</code>, <code>vietorisRips</code> or <code>tangential</code>, type <code>str</code>.</li>
<li>param <strong>maxDimensions</strong>: maximal dimension of simplices, type <code>int</code>.</li>
<li>param <strong>edgeLength</strong>: length of simplex edge, type <code>float</code>.</li>
<li>param <strong>plot</strong>: whether or not to plot, type <code>bool</code>.</li>
<li>param <strong>tikzplot</strong>: whether or not to plot as tikz-picture, type <code>bool</code>.</li>
<li>param <strong>name</strong>: name of the file to be saved, type <code>str</code>.</li>
<li>param <strong>smoothen</strong>: whether or not to smoothen the landscapes, type <code>bool</code>.</li>
<li>param <strong>sigma</strong>: smoothing factor for gaussian mixtures, type <code>int</code>.</li>
<li>return <strong>meanPersistenceLandscape</strong>: mean persistence landscape, type <code>np.ndarray</code>.</li>
</ul>
<h1 id="tdapersistencestatistics">tda.persistenceStatistics</h1>
<h2 id="hausd_interval">hausd_interval</h2>
<pre><code class="python">hausd_interval(data: numpy.ndarray, confidenceLevel: float = 0.95, subsampleSize: int = -1, subsampleNumber: int = 1000, pairwiseDist: bool = False, leafSize: int = 2, ncores: int = 2) -&gt; float
</code></pre>

<p><strong>Computation of Hausdorff distance based confidence values.</strong></p>
<p>Measures the confidence between two persistent features, wether they are drawn from
a distribution fitting the underlying manifold of the data. This function is based on
the Hausdorff distance between the points.</p>
<ul>
<li>param <strong>data</strong>: a data set, type <code>np.ndarray</code>.</li>
<li>param <strong>confidenceLevel</strong>: confidence level, default <code>0.95</code>, type <code>float</code>.</li>
<li>param <strong>subsampleSize</strong>: size of each subsample, type <code>int</code>.</li>
<li>param <strong>subsampleNumber</strong>: number of subsamples, type <code>int</code>.</li>
<li>param <strong>pairwiseDist</strong>: if <code>true</code>, a symmetric <code>nxn</code>-matrix is generated out of the data, type <code>bool</code>.</li>
<li>param <strong>leafSize</strong>: leaf size for KDTree, type <code>int</code>.</li>
<li>param <strong>ncores</strong>: number of cores for parallel computing, type <code>int</code>.</li>
<li>return <strong>confidence</strong>: the confidence to be a persistent homology class, type <code>float</code>.</li>
</ul>
<h2 id="truncated_simplex_tree">truncated_simplex_tree</h2>
<pre><code class="python">truncated_simplex_tree(simplexTree: numpy.ndarray, int_trunc: int = 100) -&gt; tuple
</code></pre>

<p><strong>This function return a truncated simplex tree.</strong></p>
<p>A sparse representation of the persistence diagram in the form of a truncated
persistence tree. Speeds up computation on large scale data sets.</p>
<ul>
<li>param <strong>simplexTree</strong>: simplex tree, type <code>np.ndarray</code>.</li>
<li>param <strong>int_trunc</strong>: number of persistent interval kept per dimension, default is <code>100</code>, type <code>int</code>.</li>
<li>return <strong>simplexTreeTruncatedPersistence</strong>: truncated simplex tree, type <code>np.ndarray</code>.</li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../auxiliary/" class="btn btn-neutral float-right" title="Auxiliary">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../clustering/" class="btn btn-neutral" title="Clustering"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../clustering/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../auxiliary/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
